function init(self)
	msg.post(".", "acquire_input_focus")
	self.instances = build_board()
	-- 槽位实例
	self.slot_instances = {}
	self.removingBlocks = 0
	self.waiting = false
end

function build_board()
	-- 设置随机数种子
	math.randomseed(os.time())
	local instances = {}
	-- 创建 7x7 的数组
	local pos = vmath.vector3()
	for i = 1, 7 do
		pos.x = 120 * 0.8 * i
		for j = 1, 7 do
			pos.y = 1300 - 135 * 0.8 * j
			local r = math.random(0, 16) -- 随机生成 0-16
			if r ~= 0 then
				table.insert(instances,
					factory.create("#block_factory", pos, nil, { block = hash("block_" .. r) },
						vmath.vector3(0.8, 0.8, 0.8)))
				msg.post("@render:", "draw_text",
					{ text = "" .. i, position = pos })
			end
		end
	end
	return instances
end

-- 删除指定范围的方块
function remove_blocks(self, start_index, count)
	self.removingBlocks = 3
	print("删除 " .. count .. " 个方块，从位置 " .. start_index .. " 开始")

	-- 删除方块实例
	for i = start_index, start_index + count - 1 do
		msg.post(self.slot_instances[i], hash("block_remove"), { start_index = start_index })
	end

	-- 从数组中移除
	for i = 1, count do
		table.remove(self.slot_instances, start_index)
	end
end

-- 检查游戏是否结束
function check_game_end(self)
	if self.removingBlocks == 0 and #self.slot_instances >= 7 then
		print("游戏结束！槽位已满，游戏失败！")
		-- 显示游戏结束界面
		msg.post("/go#game_end", "enable")
	end
end

-- 检查是否有3个或以上相同类型的方块
function on_block_move_end(self)
	if #self.slot_instances < 3 then
		return false
	end

	local i = 1
	while i <= #self.slot_instances do
		local current_hash = go.get(self.slot_instances[i], "block")
		local match_start = i
		local match_count = 1

		-- 向后查找相同类型的方块
		for j = i + 1, #self.slot_instances do
			local block_hash = go.get(self.slot_instances[j], "block")
			if block_hash == current_hash then
				match_count = match_count + 1
			else
				break
			end
		end

		-- 如果找到3个或以上相同类型的方块，删除它们
		if match_count >= 3 then
			remove_blocks(self, match_start, match_count)
			return true
		else
			i = i + match_count
		end
	end

	return false
end

-- 将点击的方块插入到槽位中
function insert_block_to_slot(self, clicked_instance)
	local clicked_block_hash = go.get(clicked_instance, "block")

	-- 查找相同元素的最后位置
	local insert_index = #self.slot_instances + 1 -- 默认插入到末尾
	for i, instance in ipairs(self.slot_instances) do
		local block_hash = go.get(instance, "block")
		if block_hash == clicked_block_hash then
			insert_index = i + 1
		end
	end
	table.insert(self.slot_instances, insert_index, clicked_instance)

	-- 新插入的元素使用动画移动
	local target_x = insert_index * 96
	msg.post(clicked_instance, hash("block_move"),
		{ to_x = target_x, speed = 3500, insert_index = insert_index, instance = clicked_instance })

	-- 更新从插入位置开始的所有元素的坐标
	for i = insert_index + 1, #self.slot_instances do
		local pos = go.get_position(self.slot_instances[i])
		pos.x = i * 96
		go.set_position(pos, self.slot_instances[i])
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("on_block_clicked") then
		insert_block_to_slot(self, message.clicked_instance)
	end
	if message_id == hash("on_block_move_end") then
		-- 其他元素直接更新位置
		-- 检查是否有3个或以上相同类型的方块需要消除
		if on_block_move_end(self) == false then
			self.waiting = false
			check_game_end(self)
		end
	end
	if message_id == hash("on_block_remove_end") then
		self.removingBlocks = self.removingBlocks - 1
		if self.removingBlocks == 0 then
			-- 重新调整剩余方块的位置
			for i = message.start_index, #self.slot_instances do
				local target_x = i * 96
				local pos = go.get_position(self.slot_instances[i])
				pos.x = target_x
				go.set_position(pos, self.slot_instances[i])
			end
			self.waiting = false
			check_game_end(self)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		for i, instance in ipairs(self.instances) do
			-- Check if instance is valid before getting position
			local success, pos = pcall(go.get_position, instance)
			if success then
				local scale = go.get_scale(instance)
				if action.x >= pos.x - 120 * scale.x / 2 and action.x <= pos.x + 120 * scale.x / 2 then
					if action.y <= pos.y + 135 * scale.y / 2 and action.y >= pos.y - 135 * scale.y / 2 then
						if self.waiting == false then
							self.waiting = true
							print("点击位置: ", action.x, action.y, "元素: ", instance)
							table.remove(self.instances, i)
							local clicked_instance = msg.url(nil, instance, "block")
							msg.post("#", hash("on_block_clicked"), { clicked_instance = clicked_instance })
						end
						print("等待中...")
						break
					end
				end
			end
		end
	end
end
